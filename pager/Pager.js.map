{"version":3,"sources":["../../src/pager/Pager.js"],"names":["Pager","pager","page","pageCount","query","pagingHandler","list","Promise","reject","total","nextPage","prevPage","hasNextPage","goToPage","hasPreviousPage","pageNr","Error","Object","assign"],"mappings":";;;;;;;;AAAA;;;;AAEA;;;;;;;AAOA;;;AAGA;IACMA,K;AACF;;;;;;;;;AASA,mBAGE;AAAA,QAFEC,KAEF,uEAFU,EAAEC,MAAM,CAAR,EAAWC,WAAW,CAAtB,EAAyBC,OAAO,EAAhC,EAEV;AAAA,QADEC,aACF,uEADkB,EAAEC,MAAM;AAAA,eAAMC,QAAQC,MAAR,CAAe,sBAAf,CAAN;AAAA,OAAR,EAClB;;AAAA;;AACE;;;AAGA,SAAKN,IAAL,GAAYD,MAAMC,IAAlB;;AAEA;;;AAGA,SAAKC,SAAL,GAAiBF,MAAME,SAAvB;;AAEA;;;;;;;AAOA,SAAKM,KAAL,GAAaR,MAAMQ,KAAnB;;AAEA;;;;;;AAMA,SAAKC,QAAL,GAAgBT,MAAMS,QAAtB;;AAEA;;;;;;AAMA,SAAKC,QAAL,GAAgBV,MAAMU,QAAtB;;AAEA;;;;;;;AAOA,SAAKP,KAAL,GAAaH,MAAMG,KAAnB;;AAEA,SAAKC,aAAL,GAAqBA,aAArB;AACH;;AAED;;;;;;;;;;kCAMc;AACV,aAAO,sBAAU,KAAKK,QAAf,CAAP;AACH;;AAED;;;;;;;;sCAKkB;AACd,aAAO,sBAAU,KAAKC,QAAf,CAAP;AACH;;AAED;;;;;;;;;;;;;;;;;;;;kCAiBc;AACV,UAAI,KAAKC,WAAL,EAAJ,EAAwB;AACpB,eAAO,KAAKC,QAAL,CAAc,KAAKX,IAAL,GAAY,CAA1B,CAAP;AACH;AACD,aAAOK,QAAQC,MAAR,CAAe,2CAAf,CAAP;AACH;;AAED;;;;;;;;;;;;;;;;;;;;;sCAkBkB;AACd,UAAI,KAAKM,eAAL,EAAJ,EAA4B;AACxB,eAAO,KAAKD,QAAL,CAAc,KAAKX,IAAL,GAAY,CAA1B,CAAP;AACH;AACD,aAAOK,QAAQC,MAAR,CAAe,+CAAf,CAAP;AACH;;AAED;;;;;;;;;;;;;;;;;AAiBA;;;;6BACSO,M,EAAQ;AACb,UAAIA,SAAS,CAAb,EAAgB;AACZ,cAAM,IAAIC,KAAJ,CAAU,+BAAV,CAAN;AACH;AACD,UAAID,SAAS,KAAKZ,SAAlB,EAA6B;AACzB,cAAM,IAAIa,KAAJ,4DAAmE,KAAKb,SAAxE,CAAN;AACH;;AAED,aAAO,KAAKE,aAAL,CAAmBC,IAAnB,CAAwBW,OAAOC,MAAP,CAAc,EAAd,EAAkB,KAAKd,KAAvB,EAA8B,EAAEF,MAAMa,MAAR,EAA9B,CAAxB,CAAP;AACH;;;;;;kBAGUf,K","file":"Pager.js","sourcesContent":["import { isDefined } from '../lib/check';\n\n/**\n * @description\n * Pager object that can be used to navigate pages within a `Modelcollection`\n *\n * @memberof module:model\n */\n\n/**\n  * @memberof module:model\n  */\n// TODO: Move to the model map\nclass Pager {\n    /**\n     * @constructor\n     *\n     * @param {Object} [pager={page: 1, pageCount: 1}] Paging information object.\n     * @param {Object} [pagingHandler={list: () => Promise.reject('No handler available')}] Paging handler object. The requirement for this object is that it has a list method.\n     *\n     * @description\n     * Returns a newly created pager object with methods to navigate pages.\n     */\n    constructor(\n        pager = { page: 1, pageCount: 1, query: {} },\n        pagingHandler = { list: () => Promise.reject('No handler available') },\n    ) {\n        /**\n         * @property {number} page Current page number\n         */\n        this.page = pager.page;\n\n        /**\n         * @property {number} pageCount The total number of pages available\n         */\n        this.pageCount = pager.pageCount;\n\n        /**\n         * @property {number} total The total number of items available.\n         *\n         * @description\n         * This represents the total number of items available in the system. Note it is not the number of items\n         * on the current page.\n         */\n        this.total = pager.total;\n\n        /**\n         * @property {string} nextPage The url to the next page.\n         *\n         * @description\n         * If there is no next page then this will be undefined.\n         */\n        this.nextPage = pager.nextPage;\n\n        /**\n         * @property {string} prevPage The url to the previous page\n         *\n         * @description\n         * If there is no previous page then this will be undefined.\n         */\n        this.prevPage = pager.prevPage;\n\n        /**\n         * @property {object} query Query parameters\n         *\n         * @description\n         * Query parameters are used for things like filtering and field selection. Used to guarantee that pages are\n         * from the same collection.\n         */\n        this.query = pager.query;\n\n        this.pagingHandler = pagingHandler;\n    }\n\n    /**\n     * @returns {Boolean} Result is true when there is a next page, false when there is not.\n     *\n     * @description\n     * Check whether there is a next page.\n     */\n    hasNextPage() {\n        return isDefined(this.nextPage);\n    }\n\n    /**\n     * Check whether there is a previous page.\n     *\n     * @returns {Boolean} Result is true when there is a previous page, false when there is not.\n     */\n    hasPreviousPage() {\n        return isDefined(this.prevPage);\n    }\n\n    /**\n     * @description\n     * Loads the next page in the collection if there is one. If no additional pages are available the Promise will reject.\n     *\n     * @returns {Promise} Promise that resolves with a new `ModelCollection` containing the next page's data. Or rejects with\n     * a string when there is no next page for this collection or when the request for the next page failed.\n     *\n     * @example\n     * d2.models.organisationUnit\n     *   .list()\n     *   .then(collection => {\n     *     collection.pager.getNextPage()\n     *       .then(secondPageCollection => {\n     *         console.log(secondPageCollection.toArray());\n     *       });\n     *   });\n     */\n    getNextPage() {\n        if (this.hasNextPage()) {\n            return this.goToPage(this.page + 1);\n        }\n        return Promise.reject('There is no next page for this collection');\n    }\n\n    /**\n     * @description\n     * Loads the previous page in the collection if there is one. If no previous pages are available the Promise will reject.\n     *\n     * @returns {Promise} Promise that resolves with a new `ModelCollection` containing the previous page's data. Or rejects with\n     * a string when there is no previous page for this collection or when the request for the previous page failed.\n     *\n     * @example\n     * d2.models.organisationUnit\n     *   .list()\n     *   .then(collection => {\n     *     collection.pager.goToPage(3)\n     *       .then(collection => collection.pager.getPreviousPage())\n     *       .then(secondPageCollection => {\n     *         console.log(secondPageCollection.toArray());\n     *       });\n     *   });\n     */\n    getPreviousPage() {\n        if (this.hasPreviousPage()) {\n            return this.goToPage(this.page - 1);\n        }\n        return Promise.reject('There is no previous page for this collection');\n    }\n\n    /**\n     * Loads a specific page for the collection. If the requested page is out of the range of available pages (e.g < 0 or > page count)\n     * the Promise will reject with an error.\n     *\n     * @param {Number} pageNr The number of the page you wish to navigate to.\n     * @returns {Promise} Promise that resolves with a new `ModelCollection` containing the data for the requested page.\n     *\n     * @example\n     * d2.models.organisationUnit\n     *   .list()\n     *   .then(collection => {\n     *     collection.pager.goToPage(4)\n     *       .then(fourthPageCollection => {\n     *         console.log(fourthPageCollection.toArray());\n     *       });\n     *   });\n     */\n    // TODO: Throwing the errors here is not really consistent with the rejection of promises for the getNextPage and getPreviousPage\n    goToPage(pageNr) {\n        if (pageNr < 1) {\n            throw new Error('PageNr can not be less than 1');\n        }\n        if (pageNr > this.pageCount) {\n            throw new Error(`PageNr can not be larger than the total page count of ${this.pageCount}`);\n        }\n\n        return this.pagingHandler.list(Object.assign({}, this.query, { page: pageNr }));\n    }\n}\n\nexport default Pager;\n"]}