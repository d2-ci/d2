{"version":3,"sources":["../../../src/model/helpers/json.js"],"names":["NON_MODEL_COLLECTIONS","aggregationLevels","grantTypes","translations","deliveryChannels","redirectUris","organisationUnitLevels","favorites","columns","rows","filters","yearlySeries","interpretations","isNonModelCollection","propertyName","modelType","modelTypes","isPlainValue","collection","isPlainValueInCollection","property","indexOf","isCollectionProperty","isReferenceProperty","getJSONForProperties","model","properties","keepFullModels","objectToSave","collectionPropertiesNames","getCollectionChildrenPropertyNames","filter","propertyNames","Object","keys","modelDefinition","modelValidations","dataValues","undefined","v","getReferenceProperties","forEach","id","name","Array","from","values","isArray","getEmbeddedObjectCollectionPropertyNames","map","childModel","clone","getOwnedPropertyJSON","ownedProperties","getOwnedPropertyNames"],"mappings":"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","sourcesContent":["import { isFunction, isEmpty, contains } from '../../lib/check'\nimport { pick } from '../../lib/utils'\n\n/**\n * Map propertyName to modelType\n * The model with propertyName will be treated as a regular array\n * (no collection) if the combination of [propertyName, modelType] exists in the object\n * Empty arrays means it applies to any modelType.\n *\n * @private\n */\nconst NON_MODEL_COLLECTIONS = {\n    aggregationLevels: ['dataElement'],\n    grantTypes: ['oAuth2Client'],\n    translations: [],\n    deliveryChannels: [\n        'programNotificationTemplate',\n        'dataSetNotificationTemplate',\n    ],\n    redirectUris: ['oAuth2Client'],\n    organisationUnitLevels: ['validationRule'],\n    favorites: [],\n    columns: [],\n    rows: [],\n    filters: [],\n    yearlySeries: [],\n    interpretations: ['chart'],\n}\n\nconst isNonModelCollection = (propertyName, modelType) => {\n    const modelTypes = NON_MODEL_COLLECTIONS[propertyName]\n\n    if (!modelTypes) {\n        return false\n    }\n\n    return contains(modelType, modelTypes) || isEmpty(modelTypes)\n}\nfunction isPlainValue(collection) {\n    return function isPlainValueInCollection(property) {\n        return collection.indexOf(property) === -1\n    }\n}\n\nfunction isCollectionProperty(collection) {\n    return property => !isPlainValue(collection)(property)\n}\n\nfunction isReferenceProperty(collection) {\n    return property => collection.indexOf(property) >= 0\n}\n\n// TODO: Misnamed as it does not actually return JSON\nexport function getJSONForProperties(\n    model,\n    properties,\n    keepFullModels = false\n) {\n    const objectToSave = {}\n    const collectionPropertiesNames = model\n        .getCollectionChildrenPropertyNames()\n        // Even though attributeValues are considered collections, they are handled separately due to their\n        // difference in structure.\n        .filter(propertyName => propertyName !== 'attributeValues')\n\n    const propertyNames = Object.keys(model.modelDefinition.modelValidations)\n        .filter(propertyName => properties.indexOf(propertyName) >= 0)\n        .filter(\n            propertyName =>\n                model.dataValues[propertyName] !== undefined &&\n                model.dataValues[propertyName] !== null\n        )\n\n    // Handle plain values\n    propertyNames\n        .filter(isPlainValue(collectionPropertiesNames))\n        .filter(v => !isReferenceProperty(model.getReferenceProperties())(v))\n        .forEach(propertyName => {\n            objectToSave[propertyName] = model.dataValues[propertyName]\n        })\n\n    // Handle reference properties\n    propertyNames\n        .filter(isPlainValue(collectionPropertiesNames))\n        .filter(isReferenceProperty(model.getReferenceProperties()))\n        .forEach(propertyName => {\n            objectToSave[propertyName] = {\n                id: model.dataValues[propertyName].id,\n            }\n        })\n\n    // Handle non-embedded collection properties\n    propertyNames\n        .filter(isCollectionProperty(collectionPropertiesNames))\n        .forEach(propertyName => {\n            // TODO: This is not the proper way to do this. We should check if the array contains Models\n            // These objects are not marked as embedded objects but they behave like they are\n            if (\n                isNonModelCollection(propertyName, model.modelDefinition.name)\n            ) {\n                objectToSave[propertyName] = Array.from(\n                    model.dataValues[propertyName]\n                )\n                return\n            }\n\n            const values = Array.isArray(model.dataValues[propertyName])\n                ? model.dataValues[propertyName]\n                : Array.from(model.dataValues[propertyName].values())\n\n            // If the collection is a embedded collection we can save it as is.\n            if (\n                model\n                    .getEmbeddedObjectCollectionPropertyNames()\n                    .indexOf(propertyName) !== -1\n            ) {\n                objectToSave[propertyName] = values\n                return\n            }\n\n            // Transform an object collection to an array of objects with id properties\n            objectToSave[propertyName] = values\n                .filter(pick('id'))\n                // For any other types we return an object with just an id\n                .map(childModel => {\n                    if (keepFullModels && isFunction(childModel.clone)) {\n                        return childModel.clone()\n                    }\n                    return { id: childModel.id }\n                })\n        })\n\n    return objectToSave\n}\n\n// TODO: Misnamed as it does not actually return JSON\nexport function getOwnedPropertyJSON(model) {\n    const ownedProperties = model.modelDefinition.getOwnedPropertyNames()\n\n    return getJSONForProperties(model, ownedProperties)\n}\n"],"file":"json.js"}