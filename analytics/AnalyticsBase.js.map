{"version":3,"sources":["../../src/analytics/AnalyticsBase.js"],"names":["AnalyticsBase","api","getApi","req","metaDataReq","withSkipMeta","withSkipData","withIncludeMetadataDetails","dataReq","withIncludeNumDen","withDisplayProperty","Promise","all","fetch","sorted","then","resolve","responses","metaData","options","get","buildUrl","buildQuery","data"],"mappings":";;;;;;;;;;AAAA;;;;AACA;;;;;;;;AAEA;;;;;;;;;;;;;IAaMA,a;AACF,6BAAgC;AAAA,YAApBC,GAAoB,uEAAd,cAAIC,MAAJ,EAAc;;AAAA;;AAC5B,aAAKD,GAAL,GAAWA,GAAX;AACH;;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;4BAwBIE,G,EAAK;AACL;AACA,gBAAMC,cAAc,+BAAqBD,GAArB,EACfE,YADe,CACF,KADE,EAEfC,YAFe,CAEF,IAFE,EAGfC,0BAHe,CAGY,IAHZ,CAApB;;AAKA,gBAAMC,UAAU,+BAAqBL,GAArB,EACXG,YADW,CACE,KADF,EAEXD,YAFW,CAEE,IAFF,EAGXI,iBAHW,GAIXC,mBAJW,CAIS,WAJT,CAAhB;;AAMA;AACA,mBAAOC,QAAQC,GAAR,CAAY,CAAC,KAAKC,KAAL,CAAWL,OAAX,EAAoB,EAAEM,QAAQ,IAAV,EAApB,CAAD,EAAwC,KAAKD,KAAL,CAAWT,WAAX,CAAxC,CAAZ,EAA8EW,IAA9E,CACH;AAAA,uBAAaJ,QAAQK,OAAR,cAAqBC,UAAU,CAAV,CAArB,IAAmCC,UAAUD,UAAU,CAAV,EAAaC,QAA1D,IAAb;AAAA,aADG,CAAP;AAGH;;AAED;;;;;;;;;;;;;;;;;;;;;;;;;8BAsBMf,G,EAAKgB,O,EAAS;AAChB,mBAAO,KAAKlB,GAAL,CACFmB,GADE,CACEjB,IAAIkB,QAAJ,CAAaF,OAAb,CADF,EACyBhB,IAAImB,UAAJ,CAAeH,OAAf,CADzB,EAEFJ,IAFE,CAEG;AAAA,uBAAQJ,QAAQK,OAAR,CAAgBO,IAAhB,CAAR;AAAA,aAFH,CAAP;AAGH;;;;;;kBAGUvB,a","file":"AnalyticsBase.js","sourcesContent":["import Api from '../api/Api';\nimport AnalyticsRequest from './AnalyticsRequest';\n\n/**\n * @private\n * @description\n * Base class for communicating with the analytics API endpoint.\n * Its subclasses can be used to get analytics data.\n *\n * @param {Instance} [api=<Api>] Api instance to use for the requests\n *\n * @requires module:api/Api\n *\n * @memberof module:analytics\n * @abstract\n */\nclass AnalyticsBase {\n    constructor(api = Api.getApi()) {\n        this.api = api;\n    }\n\n    /**\n     * Loads the analytics data and returns them as an object from the promise.\n     * Two parallel requests are made against the analytics api.\n     * One for getting only the metaData and one for getting the actual data.\n     * This is for caching purposes, as in many situations the metaData request changes while\n     * the data one will be the same and thus have the same response.\n     * This methods takes care of adding the default extra parameters to both requests.\n     *\n     * @param {!AnalyticsRequest} req Analytics request object with the request details\n     *\n     * @returns {Promise} Promise that resolves with the analytics data and metaData from the api.\n     *\n     * @example\n     * const req = new d2.analytics.request()\n     *  .addDataDimension(['Uvn6LCg7dVU','OdiHJayrsKo'])\n     *  .addPeriodDimension('LAST_4_QUARTERS')\n     *  .addOrgUnitDimension(['lc3eMKXaEfw','PMa2VCrupOd']);\n     *\n     * d2.analytics.aggregate\n     *  .get(req)\n     *  .then(analyticsData => console.log('Analytics data', analyticsData))\n     *\n     * // { metaData: { ... }, rows: [ ... ], headers: [ ... ], height: 0, width: 0 }\n     */\n    get(req) {\n        // keep metaData and data requests separate for caching purposes\n        const metaDataReq = new AnalyticsRequest(req)\n            .withSkipMeta(false)\n            .withSkipData(true)\n            .withIncludeMetadataDetails(true);\n\n        const dataReq = new AnalyticsRequest(req)\n            .withSkipData(false)\n            .withSkipMeta(true)\n            .withIncludeNumDen()\n            .withDisplayProperty('SHORTNAME');\n\n        // parallelize requests\n        return Promise.all([this.fetch(dataReq, { sorted: true }), this.fetch(metaDataReq)]).then(\n            responses => Promise.resolve({ ...responses[0], metaData: responses[1].metaData }),\n        );\n    }\n\n    /**\n     * @private\n     * @description\n     * This method does not manipulate the request object, but directly requests the data from the api\n     * based on the request's configuration.\n     *\n     * @param {!AnalyticsRequest} req Request object\n     * @param {Object} options Optional configurations, ie. for sorting dimensions\n     *\n     * @returns {Promise} Promise that resolves with the data from the api.\n     *\n     * @example\n     * const req = new d2.analytics.request()\n     *  .fromModel(chartModel)\n     *  .withSkipData();\n     *\n     * d2.analytics.aggregate\n     *  .fetch(req)\n     *  .then(analyticsData => console.log('Analytics data', analyticsData))\n     *\n     * // { metaData: { ... }, rows: [], height: 0, width: 0 }\n     */\n    fetch(req, options) {\n        return this.api\n            .get(req.buildUrl(options), req.buildQuery(options))\n            .then(data => Promise.resolve(data));\n    }\n}\n\nexport default AnalyticsBase;\n"]}