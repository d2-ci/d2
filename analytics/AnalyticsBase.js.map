{"version":3,"sources":["../../src/analytics/AnalyticsBase.js"],"names":["AnalyticsBase","api","Api","getApi","req","metaDataReq","AnalyticsRequest","withSkipMeta","withSkipData","withIncludeMetadataDetails","dataReq","Promise","all","fetch","sorted","then","responses","resolve","metaData","options","get","buildUrl","buildQuery","data"],"mappings":";;;;;;;AAAA;;AACA;;;;;;;;;;;;;;AAEA;;;;;;;;;;;;;IAaMA,a;;;AACF,2BAAgC;AAAA,QAApBC,GAAoB,uEAAdC,aAAIC,MAAJ,EAAc;;AAAA;;AAC5B,SAAKF,GAAL,GAAWA,GAAX;AACH;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;wBAwBIG,G,EAAK;AACL;AACA,UAAMC,WAAW,GAAG,IAAIC,yBAAJ,CAAqBF,GAArB,EACfG,YADe,CACF,KADE,EAEfC,YAFe,CAEF,IAFE,EAGfC,0BAHe,CAGY,IAHZ,CAApB;AAKA,UAAMC,OAAO,GAAG,IAAIJ,yBAAJ,CAAqBF,GAArB,EACXI,YADW,CACE,KADF,EAEXD,YAFW,CAEE,IAFF,CAAhB,CAPK,CAWL;;AACA,aAAOI,OAAO,CAACC,GAAR,CAAY,CACf,KAAKC,KAAL,CAAWH,OAAX,EAAoB;AAAEI,QAAAA,MAAM,EAAE;AAAV,OAApB,CADe,EAEf,KAAKD,KAAL,CAAWR,WAAX,CAFe,CAAZ,EAGJU,IAHI,CAGC,UAAAC,SAAS;AAAA,eACbL,OAAO,CAACM,OAAR,mBACOD,SAAS,CAAC,CAAD,CADhB;AAEIE,UAAAA,QAAQ,EAAEF,SAAS,CAAC,CAAD,CAAT,CAAaE;AAF3B,WADa;AAAA,OAHV,CAAP;AASH;AAED;;;;;;;;;;;;;;;;;;;;;;;;;0BAsBMd,G,EAAKe,O,EAAS;AAChB,aAAO,KAAKlB,GAAL,CACFmB,GADE,CACEhB,GAAG,CAACiB,QAAJ,CAAaF,OAAb,CADF,EACyBf,GAAG,CAACkB,UAAJ,CAAeH,OAAf,CADzB,EAEFJ,IAFE,CAEG,UAAAQ,IAAI;AAAA,eAAIZ,OAAO,CAACM,OAAR,CAAgBM,IAAhB,CAAJ;AAAA,OAFP,CAAP;AAGH;;;;;;eAGUvB,a","sourcesContent":["import Api from '../api/Api'\nimport AnalyticsRequest from './AnalyticsRequest'\n\n/**\n * @private\n * @description\n * Base class for communicating with the analytics API endpoint.\n * Its subclasses can be used to get analytics data.\n *\n * @param {Instance} [api=<Api>] Api instance to use for the requests\n *\n * @requires module:api/Api\n *\n * @memberof module:analytics\n * @abstract\n */\nclass AnalyticsBase {\n    constructor(api = Api.getApi()) {\n        this.api = api\n    }\n\n    /**\n     * Loads the analytics data and returns them as an object from the promise.\n     * Two parallel requests are made against the analytics api.\n     * One for getting only the metaData and one for getting the actual data.\n     * This is for caching purposes, as in many situations the metaData request changes while\n     * the data one will be the same and thus have the same response.\n     * This methods takes care of adding the default extra parameters to both requests.\n     *\n     * @param {!AnalyticsRequest} req Analytics request object with the request details\n     *\n     * @returns {Promise} Promise that resolves with the analytics data and metaData from the api.\n     *\n     * @example\n     * const req = new d2.analytics.request()\n     *  .addDataDimension(['Uvn6LCg7dVU','OdiHJayrsKo'])\n     *  .addPeriodDimension('LAST_4_QUARTERS')\n     *  .addOrgUnitDimension(['lc3eMKXaEfw','PMa2VCrupOd']);\n     *\n     * d2.analytics.aggregate\n     *  .get(req)\n     *  .then(analyticsData => console.log('Analytics data', analyticsData))\n     *\n     * // { metaData: { ... }, rows: [ ... ], headers: [ ... ], height: 0, width: 0 }\n     */\n    get(req) {\n        // keep metaData and data requests separate for caching purposes\n        const metaDataReq = new AnalyticsRequest(req)\n            .withSkipMeta(false)\n            .withSkipData(true)\n            .withIncludeMetadataDetails(true)\n\n        const dataReq = new AnalyticsRequest(req)\n            .withSkipData(false)\n            .withSkipMeta(true)\n\n        // parallelize requests\n        return Promise.all([\n            this.fetch(dataReq, { sorted: true }),\n            this.fetch(metaDataReq),\n        ]).then(responses =>\n            Promise.resolve({\n                ...responses[0],\n                metaData: responses[1].metaData,\n            })\n        )\n    }\n\n    /**\n     * @private\n     * @description\n     * This method does not manipulate the request object, but directly requests the data from the api\n     * based on the request's configuration.\n     *\n     * @param {!AnalyticsRequest} req Request object\n     * @param {Object} options Optional configurations, ie. for sorting dimensions\n     *\n     * @returns {Promise} Promise that resolves with the data from the api.\n     *\n     * @example\n     * const req = new d2.analytics.request()\n     *  .fromModel(chartModel)\n     *  .withSkipData();\n     *\n     * d2.analytics.aggregate\n     *  .fetch(req)\n     *  .then(analyticsData => console.log('Analytics data', analyticsData))\n     *\n     * // { metaData: { ... }, rows: [], height: 0, width: 0 }\n     */\n    fetch(req, options) {\n        return this.api\n            .get(req.buildUrl(options), req.buildQuery(options))\n            .then(data => Promise.resolve(data))\n    }\n}\n\nexport default AnalyticsBase\n"],"file":"AnalyticsBase.js"}