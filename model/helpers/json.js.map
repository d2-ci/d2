{"version":3,"sources":["../../../src/model/helpers/json.js"],"names":["getJSONForProperties","getOwnedPropertyJSON","NON_MODEL_COLLECTIONS","aggregationLevels","grantTypes","translations","deliveryChannels","redirectUris","organisationUnitLevels","favorites","columns","rows","filters","yearlySeries","interpretations","isNonModelCollection","propertyName","modelType","modelTypes","isPlainValue","collection","isPlainValueInCollection","property","indexOf","isCollectionProperty","isReferenceProperty","model","properties","keepFullModels","objectToSave","collectionPropertiesNames","getCollectionChildrenPropertyNames","filter","propertyNames","Object","keys","modelDefinition","modelValidations","dataValues","undefined","getReferenceProperties","v","forEach","id","name","Array","from","values","isArray","getEmbeddedObjectCollectionPropertyNames","map","childModel","clone","ownedProperties","getOwnedPropertyNames"],"mappings":"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","file":"json.js","sourcesContent":["import { isFunction, isEmpty, contains } from '../../lib/check';\nimport { pick } from '../../lib/utils';\n\n/**\n * Map propertyName to modelType\n * The model with propertyName will be treated as a regular array\n * (no collection) if the combination of [propertyName, modelType] exists in the object\n * Empty arrays means it applies to any modelType.\n *\n * @private\n */\nconst NON_MODEL_COLLECTIONS = {\n    aggregationLevels: ['dataElement'],\n    grantTypes: ['oAuth2Client'],\n    translations: [],\n    deliveryChannels: ['programNotificationTemplate', 'dataSetNotificationTemplate'],\n    redirectUris: ['oAuth2Client'],\n    organisationUnitLevels: ['validationRule'],\n    favorites: [],\n    columns: [],\n    rows: [],\n    filters: [],\n    yearlySeries: [],\n    interpretations: ['chart'],\n};\n\nconst isNonModelCollection = (propertyName, modelType) => {\n    const modelTypes = NON_MODEL_COLLECTIONS[propertyName];\n\n    if (!modelTypes) {\n        return false;\n    }\n\n    return contains(modelType, modelTypes) || isEmpty(modelTypes);\n};\nfunction isPlainValue(collection) {\n    return function isPlainValueInCollection(property) {\n        return collection.indexOf(property) === -1;\n    };\n}\n\nfunction isCollectionProperty(collection) {\n    return property => !isPlainValue(collection)(property);\n}\n\nfunction isReferenceProperty(collection) {\n    return property => collection.indexOf(property) >= 0;\n}\n\n// TODO: Misnamed as it does not actually return JSON\nexport function getJSONForProperties(model, properties, keepFullModels = false) {\n    const objectToSave = {};\n    const collectionPropertiesNames = model\n        .getCollectionChildrenPropertyNames()\n        // Even though attributeValues are considered collections, they are handled separately due to their\n        // difference in structure.\n        .filter(propertyName => propertyName !== 'attributeValues');\n\n    const propertyNames = Object.keys(model.modelDefinition.modelValidations)\n        .filter(propertyName => properties.indexOf(propertyName) >= 0)\n        .filter(propertyName => (\n            model.dataValues[propertyName] !== undefined &&\n            model.dataValues[propertyName] !== null),\n        );\n\n    // Handle plain values\n    propertyNames\n        .filter(isPlainValue(collectionPropertiesNames))\n        .filter(v => !isReferenceProperty(model.getReferenceProperties())(v))\n        .forEach((propertyName) => {\n            objectToSave[propertyName] = model.dataValues[propertyName];\n        });\n\n    // Handle reference properties\n    propertyNames\n        .filter(isPlainValue(collectionPropertiesNames))\n        .filter(isReferenceProperty(model.getReferenceProperties()))\n        .forEach((propertyName) => {\n            objectToSave[propertyName] = { id: model.dataValues[propertyName].id };\n        });\n\n    // Handle non-embedded collection properties\n    propertyNames\n        .filter(isCollectionProperty(collectionPropertiesNames))\n        .forEach((propertyName) => {\n            // TODO: This is not the proper way to do this. We should check if the array contains Models\n            // These objects are not marked as embedded objects but they behave like they are\n            if (isNonModelCollection(propertyName, model.modelDefinition.name)) {\n                objectToSave[propertyName] = Array.from(model.dataValues[propertyName]);\n                return;\n            }\n\n            const values = Array.isArray(model.dataValues[propertyName]) ?\n                model.dataValues[propertyName] : Array.from(model.dataValues[propertyName].values());\n\n            // If the collection is a embedded collection we can save it as is.\n            if (model.getEmbeddedObjectCollectionPropertyNames().indexOf(propertyName) !== -1) {\n                objectToSave[propertyName] = values;\n                return;\n            }\n\n            // Transform an object collection to an array of objects with id properties\n            objectToSave[propertyName] = values\n                .filter(pick('id'))\n                // For any other types we return an object with just an id\n                .map((childModel) => {\n                    if (keepFullModels && isFunction(childModel.clone)) {\n                        return childModel.clone();\n                    }\n                    return ({ id: childModel.id });\n                });\n        });\n\n    return objectToSave;\n}\n\n// TODO: Misnamed as it does not actually return JSON\nexport function getOwnedPropertyJSON(model) {\n    const ownedProperties = model.modelDefinition.getOwnedPropertyNames();\n\n    return getJSONForProperties(model, ownedProperties);\n}\n"]}