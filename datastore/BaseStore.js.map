{"version":3,"sources":["../../src/datastore/BaseStore.js"],"names":["BaseStore","api","getApi","endPoint","NamespaceClass","constructor","Error","prototype","namespace","autoLoad","Promise","resolve","get","join","then","response","length","reject","catch","e","httpStatusCode","delete","has","exists"],"mappings":"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","file":"BaseStore.js","sourcesContent":["/**\n * @module datastore\n */\n\nimport BaseStoreNamespace from './BaseStoreNamespace';\nimport Api from '../api/Api';\nimport { isArray } from '../lib/check';\n/**\n * @private\n * @description\n * Represents a key-value store that can be interacted with. This can be used to get instances of Namespaces, which\n * can be used to interact with the relating namespace API.\n *\n * @memberof module:datastore\n * @abstract\n */\nclass BaseStore {\n    constructor(api = Api.getApi(), endPoint = 'dataStore', NamespaceClass) {\n        if (this.constructor === BaseStore) {\n            throw new Error(\"Can't instantiate abstract class!\");\n        }\n        if (!(NamespaceClass.prototype instanceof BaseStoreNamespace)) {\n            throw new Error(`NamespaceClass must be subclass of ${typeof BaseStoreNamespace}`);\n        }\n        this.NamespaceClass = NamespaceClass;\n        this.endPoint = endPoint;\n        this.api = api;\n    }\n\n    /**\n     * @description\n     * Tries to get the given namespace from the server, and returns an instance of 'RetClass' that\n     * may be used to interact with this namespace. See {@link DataStoreNamespace}.\n     *\n     * @param {string} namespace To get.\n     * @param {boolean} [autoLoad=true] If true, autoloads the keys of the namespace from the server.\n     * before the namespace is created. If false, an instance of he namespace is returned without any keys.\n     * @returns {Promise<BaseStoreNamespace>} An instance of a current store-Namespace-instance representing the namespace that can be interacted with.\n     * Or an error if namespace does not exist.\n     */\n    get(namespace, autoLoad = true) {\n        if (!autoLoad) {\n            return new Promise((resolve) => {\n                resolve(new this.NamespaceClass(namespace));\n            });\n        }\n        return this.api.get([this.endPoint, namespace].join('/'))\n            .then((response) => {\n                if (response && isArray(response)) {\n                    if (response.length < 1) { // fix for api bug returning empty array instead of 404\n                        return Promise.reject(new Error('The requested namespace has no keys or does not exist.'));\n                    }\n                    return new this.NamespaceClass(namespace, response);\n                }\n                return Promise.reject(new Error('The requested namespace has no keys or does not exist.'));\n            });\n    }\n\n    /**\n     * Retrieves a list of all namespaces on the server.\n     * @returns {Promise} An array of namespaces.\n     */\n    getAll() {\n        return this.api.get(this.endPoint)\n            .then((response) => {\n                if (response && isArray(response)) {\n                    return response;\n                }\n                throw new Error('No namespaces exist.');\n            });\n    }\n\n    /**\n     * Convenience method to check if a namespace exists on the server.\n     * @param {string} namespace - Namespace to check.\n     * @returns {Promise<boolean>} True if namespace exists, false otherwise.\n     */\n    has(namespace) {\n        return this.api.get([this.endPoint, namespace].join('/'))\n            .then((response) => {\n                if (response && isArray(response)) {\n                    if (response.length < 1) { // fix for api bug returning empty array instead of 404\n                        return Promise.reject(response);\n                    }\n                    return true;\n                }\n                return Promise.reject(new Error('Response is not an array!'));\n            }).catch((e) => {\n                if (e.httpStatusCode === 404 || (isArray(e) && e.length < 1)) {\n                    return Promise.resolve(false);\n                }\n                throw e;\n            });\n    }\n\n    /**\n     * Deletes a namespace\n     *\n     * @param {string} namespace The namespace to delete.\n     * @returns {Promise} the response body from the {@link module:api.Api#get API}.\n     */\n    delete(namespace) {\n        return this.api.delete([this.endPoint, namespace].join('/'));\n    }\n\n    /**\n     * Creates a namespace. Ensures that the namespace does not exists on the server.\n     * Note that for the namespace to be saved on the server, you need to call {@link module:dataStore.BaseStoreNamespace.set set}.\n     *\n     * @param {string} namespace The namespace to create.\n     * @returns {Promise<BaseStoreNamespace>} An instance of the current store-Namespace-instance representing the namespace that can be interacted with, or\n     * an error if namespace exists.\n     */\n    create(namespace) {\n        return this.has(namespace).then(exists =>\n            (exists ? Promise.reject(new Error('Namespace already exists.')) : new this.NamespaceClass(namespace)));\n    }\n}\n\nexport default BaseStore;\n"]}