{"version":3,"sources":["../../src/datastore/BaseStoreNamespace.js"],"names":["BaseStoreNamespace","namespace","keys","api","getApi","endPoint","Error","constructor","get","join","then","response","Promise","reject","key","value","overrideUpdate","encrypt","includes","update","queryParams","post","resp","delete","filter","elem"],"mappings":"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","file":"BaseStoreNamespace.js","sourcesContent":["import Api from '../api/Api';\nimport { isString, isArray } from '../lib/check';\n\n/**\n * @private\n * @description\n * Represents a namespace in the dataStore that can be used to be used to interact with\n * the remote API.\n *\n * @property {Array} keys an array of the loaded keys.\n * @property {String} namespace name of this namespace as on the server.\n *\n * @memberof module:datastore\n */\nclass BaseStoreNamespace {\n    /**\n     * @param {string} namespace - the name of the namespace this represents.\n     * @param {string[]} keys - preloaded keys for this namespace.\n     * @param {module:api.Api} api - the api implementation, used for testing.\n     * @param {string} endPoint - the relative API-endpoint, one of ['dataStore, userDataStore'].\n     */\n    constructor(namespace, keys, api = Api.getApi(), endPoint) {\n        if (!isString(namespace)) {\n            throw new Error('BaseStoreNamespace must be called with a string to identify the Namespace');\n        }\n        if (!isString(endPoint)) {\n            throw new Error('BaseStoreNamespace must be called with an endPoint');\n        }\n        if (this.constructor === BaseStoreNamespace) {\n            throw new Error('Can\\'t instantiate abstract class!');\n        }\n\n        this.api = api;\n\n        /**\n         * The name of the namespace\n         * @type {string}\n         */\n        this.namespace = namespace;\n\n        /**\n         * an array of the loaded keys.\n         * @type {string[]}\n         */\n        this.keys = keys || [];\n        this.endPoint = endPoint;\n    }\n\n    /**\n     * Get the keys for this namespace.\n     *\n     * @returns {Promise} - The internal list of keys for current namespace.\n     */\n    getKeys() {\n        return this.api.get([this.endPoint, this.namespace].join('/')).then((response) => {\n            if (response && isArray(response)) {\n                this.keys = response;\n                return response;\n            }\n            return Promise.reject(new Error('The requested namespace has no keys or does not exist.'));\n        });\n    }\n\n    /**\n     * Retrieves the value of given key in current namespace.\n     *\n     * @param key - key to retrieve.\n     * @returns {Promise} - The value of the given key.\n     */\n    get(key) {\n        return this.api.get([this.endPoint, this.namespace, key].join('/'));\n    }\n\n    /**\n     * Sets the value of given key to given value.\n     *\n     * This will also create a new namespace on the API-end if it does not exist.\n     * If the key exists <a href='#update'> update</a> will be called, unless <code>overrideUpdate</code> equals\n     * true.\n     *\n     * @param key - key in this namespace to set.\n     * @param value - JSON-value to be set.\n     * @param [overrideUpdate=false] - If true a post-request is sent even if key exists.\n     * @param [encrypt=false] - If the value should be encrypted on the server.\n     * @returns {Promise} - the response body from the {@link module:api.Api#get API}.\n     */\n    set(key, value, overrideUpdate = false, encrypt = false) {\n        if (!overrideUpdate && this.keys.includes(key)) {\n            return this.update(key, value);\n        }\n        const queryParams = encrypt === true ? '?encrypt=true' : '';\n        return this.api.post([this.endPoint, this.namespace, key + queryParams].join('/'), value).then((resp) => {\n            this.keys = [...this.keys, key];\n            return resp;\n        });\n    }\n\n    /**\n     * Deletes given key from the API.\n     * @param {string} key - key to delete.\n     * @returns {Promise} - the response body from the {@link module:api.Api#get API}.\n     */\n    delete(key) {\n        if (!isString(key)) {\n            return Promise.reject(new Error(`Expected key to be string, but got ${typeof key}`));\n        }\n        return this.api.delete([this.endPoint, this.namespace, key].join('/')).then((resp) => {\n            this.keys = this.keys.filter(elem => elem !== key);\n            return resp;\n        });\n    }\n\n    /**\n     * Updates a key with given value.\n     * @param key - key to update.\n     * @param value - value to update to.\n     * @returns {Promise} - the response body from the {@link module:api.Api#get API}.\n     */\n    update(key, value) {\n        return this.api.update([this.endPoint, this.namespace, key].join('/'), value);\n    }\n}\n\nexport default BaseStoreNamespace;\n"]}