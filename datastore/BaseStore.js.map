{"version":3,"sources":["../../src/datastore/BaseStore.js"],"names":["BaseStore","api","Api","getApi","endPoint","NamespaceClass","constructor","Error","prototype","BaseStoreNamespace","namespace","autoLoad","Promise","resolve","get","join","then","response","length","reject","catch","e","httpStatusCode","delete","has","exists"],"mappings":"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","sourcesContent":["/**\n * @module datastore\n */\n\nimport BaseStoreNamespace from './BaseStoreNamespace';\nimport Api from '../api/Api';\nimport { isArray } from '../lib/check';\n/**\n * @private\n * @description\n * Represents a key-value store that can be interacted with. This can be used to get instances of Namespaces, which\n * can be used to interact with the relating namespace API.\n *\n * @memberof module:datastore\n * @abstract\n */\nclass BaseStore {\n    constructor(api = Api.getApi(), endPoint = 'dataStore', NamespaceClass) {\n        if (this.constructor === BaseStore) {\n            throw new Error(\"Can't instantiate abstract class!\");\n        }\n        if (!(NamespaceClass.prototype instanceof BaseStoreNamespace)) {\n            throw new Error(`NamespaceClass must be subclass of ${typeof BaseStoreNamespace}`);\n        }\n        this.NamespaceClass = NamespaceClass;\n        this.endPoint = endPoint;\n        this.api = api;\n    }\n\n    /**\n     * @description\n     * Tries to get the given namespace from the server, and returns an instance of 'RetClass' that\n     * may be used to interact with this namespace. See {@link DataStoreNamespace}.\n     *\n     * @param {string} namespace To get.\n     * @param {boolean} [autoLoad=true] If true, autoloads the keys of the namespace from the server.\n     * before the namespace is created. If false, an instance of he namespace is returned without any keys.\n     * @returns {Promise<BaseStoreNamespace>} An instance of a current store-Namespace-instance representing the namespace that can be interacted with.\n     * Or an error if namespace does not exist.\n     */\n    get(namespace, autoLoad = true) {\n        if (!autoLoad) {\n            return new Promise((resolve) => {\n                resolve(new this.NamespaceClass(namespace));\n            });\n        }\n        return this.api.get([this.endPoint, namespace].join('/'))\n            .then((response) => {\n                if (response && isArray(response)) {\n                    if (response.length < 1) { // fix for api bug returning empty array instead of 404\n                        return Promise.reject(new Error('The requested namespace has no keys or does not exist.'));\n                    }\n                    return new this.NamespaceClass(namespace, response);\n                }\n                return Promise.reject(new Error('The requested namespace has no keys or does not exist.'));\n            });\n    }\n\n    /**\n     * Retrieves a list of all namespaces on the server.\n     * @returns {Promise} An array of namespaces.\n     */\n    getAll() {\n        return this.api.get(this.endPoint)\n            .then((response) => {\n                if (response && isArray(response)) {\n                    return response;\n                }\n                throw new Error('No namespaces exist.');\n            });\n    }\n\n    /**\n     * Convenience method to check if a namespace exists on the server.\n     * @param {string} namespace - Namespace to check.\n     * @returns {Promise<boolean>} True if namespace exists, false otherwise.\n     */\n    has(namespace) {\n        return this.api.get([this.endPoint, namespace].join('/'))\n            .then((response) => {\n                if (response && isArray(response)) {\n                    if (response.length < 1) { // fix for api bug returning empty array instead of 404\n                        return Promise.reject(response);\n                    }\n                    return true;\n                }\n                return Promise.reject(new Error('Response is not an array!'));\n            }).catch((e) => {\n                if (e.httpStatusCode === 404 || (isArray(e) && e.length < 1)) {\n                    return Promise.resolve(false);\n                }\n                throw e;\n            });\n    }\n\n    /**\n     * Deletes a namespace\n     *\n     * @param {string} namespace The namespace to delete.\n     * @returns {Promise} the response body from the {@link module:api.Api#get API}.\n     */\n    delete(namespace) {\n        return this.api.delete([this.endPoint, namespace].join('/'));\n    }\n\n    /**\n     * Creates a namespace. Ensures that the namespace does not exists on the server.\n     * Note that for the namespace to be saved on the server, you need to call {@link module:dataStore.BaseStoreNamespace.set set}.\n     *\n     * @param {string} namespace The namespace to create.\n     * @returns {Promise<BaseStoreNamespace>} An instance of the current store-Namespace-instance representing the namespace that can be interacted with, or\n     * an error if namespace exists.\n     */\n    create(namespace) {\n        return this.has(namespace).then(exists =>\n            (exists ? Promise.reject(new Error('Namespace already exists.')) : new this.NamespaceClass(namespace)));\n    }\n}\n\nexport default BaseStore;\n"],"file":"BaseStore.js"}